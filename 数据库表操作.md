[toc]

# 创建和管理表


## 标识符命名规则


- 数据库名、表名不能超过30个字符，变量名限制为 29 个；
- 必须只能包含 `A~Z`、`a~z`、`0~9` 共 63 个字符;
- 数据库名、表名、字段名等对象名中间不能包含空格;
- 同一个 mysql 软件中，数据库不能重名，同一个数据库中表名不能重复，同一个表中字段名不能重复;
- 必须保证字段没有和保留字、数据库系统或常用方法冲突，如果坚持要使用，需要在sql 语句中使用 ` 着重号包裹;
- 保持字段名和类型的一致，在命名字段，并为其指定数据类型的时候一定要保证一致性；


## mysql 中的数据类型

| 类型 | 类型举例 |
| -- | -- |
| 整数类型 | `TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT 或 INTEGER`、`BIGINT` |
| 浮点类型 | `FLOAT`、`DOUBLE` |
| 定点数类型 | `DECIMAL` |
| 位类型 | `BIT` |
| 日期时间类型 | `YEAR`、`TIME`、`DATE`、`DATETIME`、`TIMESTAMP` |
| 文本字符串类型 | `CHAR`、`VARCHAR`、`TINYTEXT`、`TEXT`、`MEDIUMINT`、`LONGTEXT` |
| 枚举类型 | `ENUM` |
| 集合类型 | `SET` |
| 二进制字符串类型 | `BINARY`、`VARBINARY`、`TINYBLOB`、`BLOB`、`MEDIUEBLOB`、`LONGBLOB` |
| JSON类型 | JSON对象、JSON数组 |
| 空间数据类型 | 单值: `GEOMETRY`、`POINT`、`LINESTRING`、`POLYGON` <br/> 集合: `MULTIPOINT`、`MULTILINESTRING`、`MULTIPOLYGON`、`GEOMETRYCOLLECTION` |


常用的数据类型如下:

| 数据类型 | 描述 |
| -- | -- |
| `INT` | 从 `-2^31 ~ 2^31 -1` 区间的整型数据。存储大小位 4 字节; |
| `CHAR(size)` | 定长字符数据。若未指定，默认为 1 个字符，最大长度 255 ; |
| `VARCHAR(size)` | 可变长字符数据，根据字符串实际长度保存，必须指定长度; |
| `FLOAT(M, D)` | 单精度，占用 4 字节。</br> M: 总的位数(整数位+小数位) </br> D: 小数位，例如 FLOAT(7, 4) 表示总位数可以有7位，其中4位在小数点后。</br> D<=M<=255，0<=D<=30，默认 M+D<=6 |
| `DOUBLE(M, D)` | 双精度，占用 8 字节。</br> D<=M<=255，0<=D<=30，默认 M+D<=15 |
| `DECIMAL(M, D)` | 高精度小数，占用 M+2 个字节。 </br> D<=M<=65，0<=D<=30，最大取值范围与 `DOUBLE` 相同。 |
| `DATE` | 日期类型数据，格式 `YYYY-MM-DD` |
| `BLOB` | 二进制形式的长文本数据，最大可达 4G; |
| `TEXT` | 长文本数据，最大可达 4G; |


# 创建和管理数据库

## 创建数据库

```sql
# 方式1
CREATE DATABASE 数据库名称;

# 方式2 创建数据库并指定字符集
CREATE DATABASE 数据库名 CHARACTER SET 字符集;

# 方式3 判断数据库是否存在，不存在则创建
CREATE DATABASE IF NOT EXISTS 数据库名;
```

## 使用数据库

1. 查看当前所有的数据库

```sql
SHOW DATABASES;
```

2. 查看当前使用的数据库

```sql
SELECT DATABASE();
```

3. 查看指定数据库下的所有表

```sql
SHOW TABLES() FROM 数据库名;

# 如果是查看当前选定的数据库，可以省略 FROM 子句
SHOW TABLES();
```

4. 查看数据库的创建信息

```sql
SHOW CREATE DATABASE 数据库名;

或

SHOW CREATE DATABASE 数据库名\G;
```

5. 使用/切换数据库

```sql
USE 数据库名;
```

## 修改数据库


修改数据库字符集
   
```sql
# 字符集 GBK、UTF-8 等
ALTER DATABASE 数据库名 CHARACTER SET 字符集;
```


## 删除数据库

```sql
# 删除指定数据库
DROP DATABASE 数据库名;

# 删除指定数据库
DROP DATABASE IF EXISTS 数据库名;
```

# 创建表

## 创建表

```sql
CREATE TABLE [IF NOT EXISTS] 表名(
    字段1 数据类型 [约束条件] [默认值],
    字段2 数据类型 [约束条件] [默认值],
    字段3 数据类型 [约束条件] [默认值],
    ...
    [表约束条件]
)
```

`IF NOT EXISTS` 关键字，表示 如果数据库中已经存在了对应的表，则忽略建表语句，不再重复创建表。如果数据库中没有对应的表，则创建对应的表;

建表 case

```sql
create table if not exists 
emp(
    # int 类型
    emp_id int, 
    # 最多保存 20 个中英文字符
    emp_name varchar(20), 
    # 总位数不超过15位
    salary double, 
    # 日期类型
    birthday date
    );

desc emp;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| emp_id   | int         | YES  |     | NULL    |       |
| emp_name | varchar(20) | YES  |     | NULL    |       |
| salary   | double      | YES  |     | NULL    |       |
| birthday | date        | YES  |     | NULL    |       |
+----------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

## 创建表并导入数据

使用 `AS subquery` 选项，将创建表和插入数据结合起来

- 指定的列需要和子查询中的列要一一对应;
- 通过列名和默认值定义列;

```sql
create table if not exists emp2(
    字段1 数据类型 [约束条件] [默认值],
    字段2 数据类型 [约束条件] [默认值],
    ...
)
AS subquery;
```

创建 emp1 表，并导入 employees 表中的所有数据

```sql
create table emp1 as select * from employees;

Query OK, 107 rows affected, 2 warnings (0.06 sec)
Records: 107  Duplicates: 0  Warnings: 2
```

创建 emp2 表，并导入 employees 表中 department_id = 80 的用户数据

```sql
create table emp2 as select * from employees where department_id = 80;

Query OK, 34 rows affected, 2 warnings (0.04 sec)
Records: 34  Duplicates: 0  Warnings: 2

select * from emp2;
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
| employee_id | first_name  | last_name  | email    | phone_number       | hire_date  | job_id | salary   | commission_pct | manager_id | department_id |
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
|         145 | John        | Russell    | JRUSSEL  | 011.44.1344.429268 | 1996-10-01 | SA_MAN | 14000.00 |           0.40 |        100 |            80 |
|         146 | Karen       | Partners   | KPARTNER | 011.44.1344.467268 | 1997-01-05 | SA_MAN | 13500.00 |           0.30 |        100 |            80 |
|         147 | Alberto     | Errazuriz  | AERRAZUR | 011.44.1344.429278 | 1997-03-10 | SA_MAN | 12000.00 |           0.30 |        100 |            80 |
|         148 | Gerald      | Cambrault  | GCAMBRAU | 011.44.1344.619268 | 1999-10-15 | SA_MAN | 11000.00 |           0.30 |        100 |            80 |
|         149 | Eleni       | Zlotkey    | EZLOTKEY | 011.44.1344.429018 | 2000-01-29 | SA_MAN | 10500.00 |           0.20 |        100 |            80 |
|         150 | Peter       | Tucker     | PTUCKER  | 011.44.1344.129268 | 1997-01-30 | SA_REP | 10000.00 |           0.30 |        145 |            80 |
|         151 | David       | Bernstein  | DBERNSTE | 011.44.1344.345268 | 1997-03-24 | SA_REP |  9500.00 |           0.25 |        145 |            80 |
|         152 | Peter       | Hall       | PHALL    | 011.44.1344.478968 | 1997-08-20 | SA_REP |  9000.00 |           0.25 |        145 |            80 |
|         153 | Christopher | Olsen      | COLSEN   | 011.44.1344.498718 | 1998-03-30 | SA_REP |  8000.00 |           0.20 |        145 |            80 |
|         154 | Nanette     | Cambrault  | NCAMBRAU | 011.44.1344.987668 | 1998-12-09 | SA_REP |  7500.00 |           0.20 |        145 |            80 |
|         155 | Oliver      | Tuvault    | OTUVAULT | 011.44.1344.486508 | 1999-11-23 | SA_REP |  7000.00 |           0.15 |        145 |            80 |
|         156 | Janette     | King       | JKING    | 011.44.1345.429268 | 1996-01-30 | SA_REP | 10000.00 |           0.35 |        146 |            80 |
|         157 | Patrick     | Sully      | PSULLY   | 011.44.1345.929268 | 1996-03-04 | SA_REP |  9500.00 |           0.35 |        146 |            80 |
|         158 | Allan       | McEwen     | AMCEWEN  | 011.44.1345.829268 | 1996-08-01 | SA_REP |  9000.00 |           0.35 |        146 |            80 |
|         159 | Lindsey     | Smith      | LSMITH   | 011.44.1345.729268 | 1997-03-10 | SA_REP |  8000.00 |           0.30 |        146 |            80 |
|         160 | Louise      | Doran      | LDORAN   | 011.44.1345.629268 | 1997-12-15 | SA_REP |  7500.00 |           0.30 |        146 |            80 |
|         161 | Sarath      | Sewall     | SSEWALL  | 011.44.1345.529268 | 1998-11-03 | SA_REP |  7000.00 |           0.25 |        146 |            80 |
|         162 | Clara       | Vishney    | CVISHNEY | 011.44.1346.129268 | 1997-11-11 | SA_REP | 10500.00 |           0.25 |        147 |            80 |
|         163 | Danielle    | Greene     | DGREENE  | 011.44.1346.229268 | 1999-03-19 | SA_REP |  9500.00 |           0.15 |        147 |            80 |
|         164 | Mattea      | Marvins    | MMARVINS | 011.44.1346.329268 | 2000-01-24 | SA_REP |  7200.00 |           0.10 |        147 |            80 |
|         165 | David       | Lee        | DLEE     | 011.44.1346.529268 | 2000-02-23 | SA_REP |  6800.00 |           0.10 |        147 |            80 |
|         166 | Sundar      | Ande       | SANDE    | 011.44.1346.629268 | 2000-03-24 | SA_REP |  6400.00 |           0.10 |        147 |            80 |
|         167 | Amit        | Banda      | ABANDA   | 011.44.1346.729268 | 2000-04-21 | SA_REP |  6200.00 |           0.10 |        147 |            80 |
|         168 | Lisa        | Ozer       | LOZER    | 011.44.1343.929268 | 1997-03-11 | SA_REP | 11500.00 |           0.25 |        148 |            80 |
|         169 | Harrison    | Bloom      | HBLOOM   | 011.44.1343.829268 | 1998-03-23 | SA_REP | 10000.00 |           0.20 |        148 |            80 |
|         170 | Tayler      | Fox        | TFOX     | 011.44.1343.729268 | 1998-01-24 | SA_REP |  9600.00 |           0.20 |        148 |            80 |
|         171 | William     | Smith      | WSMITH   | 011.44.1343.629268 | 1999-02-23 | SA_REP |  7400.00 |           0.15 |        148 |            80 |
|         172 | Elizabeth   | Bates      | EBATES   | 011.44.1343.529268 | 1999-03-24 | SA_REP |  7300.00 |           0.15 |        148 |            80 |
|         173 | Sundita     | Kumar      | SKUMAR   | 011.44.1343.329268 | 2000-04-21 | SA_REP |  6100.00 |           0.10 |        148 |            80 |
|         174 | Ellen       | Abel       | EABEL    | 011.44.1644.429267 | 1996-05-11 | SA_REP | 11000.00 |           0.30 |        149 |            80 |
|         175 | Alyssa      | Hutton     | AHUTTON  | 011.44.1644.429266 | 1997-03-19 | SA_REP |  8800.00 |           0.25 |        149 |            80 |
|         176 | Jonathon    | Taylor     | JTAYLOR  | 011.44.1644.429265 | 1998-03-24 | SA_REP |  8600.00 |           0.20 |        149 |            80 |
|         177 | Jack        | Livingston | JLIVINGS | 011.44.1644.429264 | 1998-04-23 | SA_REP |  8400.00 |           0.20 |        149 |            80 |
|         179 | Charles     | Johnson    | CJOHNSON | 011.44.1644.429262 | 2000-01-04 | SA_REP |  6200.00 |           0.10 |        149 |            80 |
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
34 rows in set (0.00 sec)
```

创建 emp3 表，并导入 employees 表中 department_id = 80 的用户的 employee_id 和 last_name 字段 作为表数据

```sql
create table emp3 as select employee_id, last_name from employees where department_id = 80;

Query OK, 34 rows affected (0.03 sec)
Records: 34  Duplicates: 0  Warnings: 0

select * from emp3;
+-------------+------------+
| employee_id | last_name  |
+-------------+------------+
|         145 | Russell    |
|         146 | Partners   |
|         147 | Errazuriz  |
|         148 | Cambrault  |
|         149 | Zlotkey    |
|         150 | Tucker     |
|         151 | Bernstein  |
|         152 | Hall       |
|         153 | Olsen      |
|         154 | Cambrault  |
|         155 | Tuvault    |
|         156 | King       |
|         157 | Sully      |
|         158 | McEwen     |
|         159 | Smith      |
|         160 | Doran      |
|         161 | Sewall     |
|         162 | Vishney    |
|         163 | Greene     |
|         164 | Marvins    |
|         165 | Lee        |
|         166 | Ande       |
|         167 | Banda      |
|         168 | Ozer       |
|         169 | Bloom      |
|         170 | Fox        |
|         171 | Smith      |
|         172 | Bates      |
|         173 | Kumar      |
|         174 | Abel       |
|         175 | Hutton     |
|         176 | Taylor     |
|         177 | Livingston |
|         179 | Johnson    |
+-------------+------------+
34 rows in set (0.00 sec)
```

创建 emp4 表，跟 employees 表结构相同，但不导入数据

```sql
create table emp4 as select * from employees where 1 = 2;

Query OK, 0 rows affected, 2 warnings (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 2
```


## 修改表

修改表是指修改数据库中已经存在的数据表的结构;

使用 `ALTER TABLE` 语句可以实现:

- 向已有的表中添加列;
- 修改现有表中的列；
- 删除现有表中的列;
- 重命名现有表中的列;


### 追加一个列

追加一个列的语法格式如下:

```sql
ALTER TABLE 表名 ADD 字段名 字段类型 [约束条件];
```

case1:

```sql
desc emp3;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| employee_id | int         | NO   |     | 0       |       |
| last_name   | varchar(25) | NO   |     | NULL    |       |
+-------------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

alter table emp3 add salary double not null default 0.0;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

desc emp3;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| employee_id | int         | NO   |     | 0       |       |
| last_name   | varchar(25) | NO   |     | NULL    |       |
| salary      | double      | NO   |     | 0       |       |
+-------------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```


### 修改列

修改列语法格式

```sql
ALTER TABLE 表名 MODIFY [COLUMN] 字段名1 字段类型 [约束条件] [DEFAUT 默认值];
```


case 修改 last_name 为 30 个字符，不为空，默认值为 ''

```sql
desc emp3;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| employee_id | int         | NO   |     | 0       |       |
| last_name   | varchar(25) | NO   |     | NULL    |       |
| salary      | double      | YES  |     | 0       |       |
+-------------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)


alter table emp3 modify last_name varchar(30) not null default '';
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0


desc emp3;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| employee_id | int         | NO   |     | 0       |       |
| last_name   | varchar(30) | NO   |     |         |       |
| salary      | double      | YES  |     | 0       |       |
+-------------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```


### 重命名列

重命名列语法格式

```sql
ALTER TABLE 表名 CHANGE [column] 列名 新列名 数据类型;
```

case 修改 last_name 为 employee_name

```sql
desc emp3;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| employee_id | int         | NO   |     | 0       |       |
| last_name   | varchar(30) | NO   |     |         |       |
| salary      | double      | YES  |     | 0       |       |
+-------------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)


alter table emp3 change last_name employee_name varchar(30);
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0


desc emp3;
+---------------+-------------+------+-----+---------+-------+
| Field         | Type        | Null | Key | Default | Extra |
+---------------+-------------+------+-----+---------+-------+
| employee_id   | int         | NO   |     | 0       |       |
| employee_name | varchar(30) | YES  |     | NULL    |       |
| salary        | double      | YES  |     | 0       |       |
+---------------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```


### 删除列

删除列语法格式

```sql
ALTER TABLE 表名 DROP [COLUMN] 字段名;
```

case 先添加 salary1 和 salary2 字段，然后删除

```sql
desc emp3;
+---------------+-------------+------+-----+---------+-------+
| Field         | Type        | Null | Key | Default | Extra |
+---------------+-------------+------+-----+---------+-------+
| employee_id   | int         | NO   |     | 0       |       |
| employee_name | varchar(30) | YES  |     | NULL    |       |
+---------------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

# 添加 salary1 和 salary2
# column 关键字可以省略
alter table emp3 add column salary1 double not null default 1000.0;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

alter table emp3 add salary2 double not null default 2000.0;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

desc emp3;
+---------------+-------------+------+-----+---------+-------+
| Field         | Type        | Null | Key | Default | Extra |
+---------------+-------------+------+-----+---------+-------+
| employee_id   | int         | NO   |     | 0       |       |
| employee_name | varchar(30) | YES  |     | NULL    |       |
| salary1       | double      | NO   |     | 1000    |       |
| salary2       | double      | NO   |     | 2000    |       |
+---------------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)


# 删除 salary1 和 salary2 两列
# 同样 column 关键字可以省略
alter table emp3 drop column salary1;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

alter table emp3 drop salary2;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

desc emp3;
+---------------+-------------+------+-----+---------+-------+
| Field         | Type        | Null | Key | Default | Extra |
+---------------+-------------+------+-----+---------+-------+
| employee_id   | int         | NO   |     | 0       |       |
| employee_name | varchar(30) | YES  |     | NULL    |       |
+---------------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```


# 数据增删改

## 插入数据 `INSERT`

### 使用 `INSERT` 插入数据

插入数据语法格式

```sql
# 插入一条数据
# VALUES 值列表中需要为每个字段指定值，并且指定值的顺序必须和数据表中字段定义的顺序保持一致;
INSERT INTO 表名 VALUES(value1, value2, ...);

# 插入一条数据，指定字段设置值
# 指定字段设置值，没有指定的字段取默认值
# VALUES 中的值的顺序，要与目标字段的顺序保持一致
INSERT INTO 表名 (column1, column3, column5, ...) VALUES(value1, value3, value5, ...);

# 插入多条数据
# INSERT 插入多条数据时，VALUES 后的每一条数据之间需要使用 逗号 分隔;
INSERT INTO 表名
VALUES
(value1, value2, ...),
(value1, value2, ...),
(value1, value2, ...);
```

```sql
desc emp5;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| employee_id | int         | NO   |     | 0       |       |
| last_name   | varchar(25) | NO   |     | NULL    |       |
| salary      | double(8,2) | YES  |     | NULL    |       |
+-------------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)


# 插入一条数据
insert into emp5 values(1, 'zhangsan', 10000);
Query OK, 1 row affected (0.01 sec)

select * from emp5;
+-------------+-----------+----------+
| employee_id | last_name | salary   |
+-------------+-----------+----------+
|           1 | zhangsan  | 10000.00 |
+-------------+-----------+----------+
1 row in set (0.00 sec)


# 插入数据，指定列
insert into emp5 (last_name, employee_id) values('lisi', 2);
Query OK, 1 row affected (0.01 sec)

select * from emp5;
+-------------+-----------+----------+
| employee_id | last_name | salary   |
+-------------+-----------+----------+
|           1 | zhangsan  | 10000.00 |
|           2 | lisi      |     NULL |
+-------------+-----------+----------+
2 rows in set (0.00 sec)

# 插入多列数据
insert into emp5 (employee_id, last_name) values (3, 'aa'), (4, 'bb');
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0

select * from emp5;
+-------------+-----------+----------+
| employee_id | last_name | salary   |
+-------------+-----------+----------+
|           1 | zhangsan  | 10000.00 |
|           2 | lisi      |     NULL |
|           3 | aa        |     NULL |
|           4 | bb        |     NULL |
+-------------+-----------+----------+
4 rows in set (0.00 sec)
```

### 使用查询结果插入到表中

`INSERT` 可以将 `SELECT` 语句查询结果插入到表中，此时不需要把每一条记录的值一个一个的输入，只需要使用一条 `INSERT` 语句和一条 `SElECT` 语句组成的组合语句即可快速的从一个或多个表中向一个表中插入多行数据;

语法如下:

```sql
# 在 INSERT 语句中加入子查询，不必书写 VALUES 子句
# 子查询的值列表应与 INSERT 子句中的列名对应;
INSERT INTO 目标表名 (column1, column2, ...)
SELECT (column1, column2, ...) FROM 源表名 [WHERE CONDITION];
```

```sql
desc emp5;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| employee_id | int         | NO   |     | 0       |       |
| last_name   | varchar(25) | NO   |     | NULL    |       |
| salary      | double(8,2) | YES  |     | NULL    |       |
+-------------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

select * from emp5;
+-------------+-----------+----------+
| employee_id | last_name | salary   |
+-------------+-----------+----------+
|           1 | zhangsan  | 10000.00 |
|           2 | lisi      |     NULL |
|           3 | aa        |     NULL |
|           4 | bb        |     NULL |
+-------------+-----------+----------+
4 rows in set (0.00 sec)


select employee_id, last_name, salary from employees where salary > 15000;
+-------------+-----------+----------+
| employee_id | last_name | salary   |
+-------------+-----------+----------+
|         100 | King      | 24000.00 |
|         101 | Kochhar   | 17000.00 |
|         102 | De Haan   | 17000.00 |
+-------------+-----------+----------+
3 rows in set (0.00 sec)


# 插入查询结果

insert into emp5 (employee_id, last_name, salary) select employee_id, last_name, salary from employees where salary > 15000;
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

select * from emp5;
+-------------+-----------+----------+
| employee_id | last_name | salary   |
+-------------+-----------+----------+
|           1 | zhangsan  | 10000.00 |
|           2 | lisi      |     NULL |
|           3 | aa        |     NULL |
|           4 | bb        |     NULL |
|         100 | King      | 24000.00 |
|         101 | Kochhar   | 17000.00 |
|         102 | De Haan   | 17000.00 |
+-------------+-----------+----------+
7 rows in set (0.00 sec)
```


## 数据更新 `UPDATE`

数据更新语法如下

```sql
UPDATE 表名 SET column1=value1, column2=value2, ... [WHERE condition];
```

- 数据更新时，可以一次性更新多条数据;
- 如果需要回滚数据，需要保证在 DML 前进行设置: `SET AUTOCOMMIT = FALSE;`
- 如果省略 WHERE 子句，则表中所有的数据都会被更新;


## 删除数据 `DELETE`

删除数据语法格式

```sql
DELETE FROM 表名 [WHERE condition];
```

如果不配置 `WHERE` 子句，则表中的所有数据都会被删除;


# `Mysql` 中的数据类型详细分析

| 类型 | 类型举例 |
| -- | -- |
| 整数类型 | `TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT` 或 `INTEGER`、`BIGINT` |
| 浮点类型 | `FLOAT`、`DOUBLE` |
| 定点数类型 | `DECIMAL` |
| 位类型 | `BIT` |
| 日期时间类型 | `YEAR`、`DATE`、`TIME`、`DATETIME`、`TIMESTAMP` |
| 文本字符串类型 | `CHAR`、`VARCHAR`、`TINYTEXT`、`TEXT`、`MEDIUMTEXT`、`LONGTEXT` |
| 枚举类型 | `ENUM` |
| 集合类型 | `SET` |
| 二进制字符串类型 | `BINARY`、`VARBINARY`、`TINYBLOB`、`BLOB`、`MEDIUMBLOB`、`LONGBLOB` |
| JSON类型 | `JSON对象`、`JSON数组` |
| 空间数据类型 | 单值类型: `GEOMETRY`、`POINT`、`LINESTRING`、`POLYGON` </br> 集合类型: `MULTIPOINT`、`MULTILINESTRING`、`MULTIPOLYGON`、`GEOMETRYCOLLECTION` |


常见数据类型的属性，如下:

| Mysql关键字 | 含义 |
| -- | -- |
| `NULL` | 数据列可包含 `NULL` 值 |
| `NOT NULL` | 数据列不允许包含 `NULL` 值 |
| `DEFAULT` | 默认值 |
| `PRIMARY KEY` | 主键 |
| `AUTO_INCREMENT` | 自动递增，适用于整数类型 |
| `UNSIGNED` | 无符号 |
| `CHARACTER SET name` | 指定一个字符集 |


## 整数类型

### 类型介绍

mysql 中整数类型有五种，包括 `TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT` 或 `INTEGER` 、`BIGINT`，主要的区别如下

| 整数类型 | 字节 | 有符号数取值范围 | 无符号数取值范围 |
| -- | -- | -- | -- |
| `TINYINT` | `1`| `-128 ~ 127` | `0 ~ 255` |
| `SMALLINT` | `2` | `-32768 ~ 32767` | `0 ~ 65535` |
| `MEDIUMINT` | `3` | `-8388608 ~ 8388607` | `0 ~ 16777215` |
| `INT` 或 `INTEGER` | `4` | `-2147483648 ~ 2147483647` | `0 ~ 4294967295` |
| `BIGINT` | `8` | `-9223372036854775808 ~ 9223372036854775807` | `0 ~ 18446744073709551615` |


### 可选属性

整数类型的可选属性总共有三个

#### 显示宽度 `M`

`M` 表示显示宽度（ 表示的是显示的十进制的位数， 而不是占用 `M` 个二进制位内存 ），`M` 的取值范围是 `0 ~ 255`，例如 `int(5)`: 表示当数据宽度小于 5 位的时候在数字前面需要用字符填充宽度。该项功能需要配合 `ZEROFILL` 使用，表示用 `0` 填充宽度，否则指定显示宽度无效;

显示宽度与类型可以存储的值范围无关 (例如: `int(5)` 存储 `123456` 也是正常存储的)。从 `Mysql 8.0.17` 开始，整数数据类型不推荐使用显示宽度属性;

整数数据类型可以在定义表结构的时候指定所需要的显示宽度，如果不指定，则系统位每一种类型指定默认的宽度值；

```sql
create table if not exists test_integer_tab(a tinyint, b smallint, c mediumint, d int, e integer, f bigint);

# mysql8 不在显示范围
desc test_integer_tab;
+-------+-----------+------+-----+---------+-------+
| Field | Type      | Null | Key | Default | Extra |
+-------+-----------+------+-----+---------+-------+
| a     | tinyint   | YES  |     | NULL    |       | 4
| b     | smallint  | YES  |     | NULL    |       | 6
| c     | mediumint | YES  |     | NULL    |       | 9
| d     | int       | YES  |     | NULL    |       | 11
| e     | int       | YES  |     | NULL    |       | 11
| f     | bigint    | YES  |     | NULL    |       | 20
+-------+-----------+------+-----+---------+-------+
6 rows in set (0.00 sec)
```

验证位宽度使用，位宽度需要配合 `zerofill` 使用

注意: 如果在整数类型的上使用 `zerofill` 时，mysql 会自动为当前列添加 `unsigned` 属性，即: `a tinyint(3) zerofill` 实际上为 `a tinyint(3) unsigned zerofill`

```sql
create table if not exists test2(a tinyint(3), b tinyint(3) zerofill, c int(4), d int(4) zerofill);

insert into test2 values(1, 1, 1, 1), (10, 10, 10, 10), (100, 100, 100, 100), (null, null, 10000, 10000);

# 可以看到只有声明了 zerofill 后，位宽度才会生效
select * from test2;
+------+------+-------+-------+
| a    | b    | c     | d     |
+------+------+-------+-------+
|    1 |  001 |     1 |  0001 |
|   10 |  010 |    10 |  0010 |
|  100 |  100 |   100 |  0100 |
| NULL | NULL | 10000 | 10000 |
+------+------+-------+-------+
4 rows in set (0.00 sec)
```


### 无符号类型 `UNSIGNED`

`UNSIGNED` 无符号类型 (非负数)，所有的整数类型都有一个可选的属性 `UNSIGNED`，无符号整数类型的最小值为 `0`。所以，如果要在 mysql 中保存一个非负数整数值时，可以将整数类型设置为无符号类型；

`INT` 类型的默认显示宽度为 `INT(11)`，无符号 `INT` 类型的默认显示宽度为 `INT(0)`;


```sql
create table if not exists test3 (a tinyint(3), b tinyint(3) zerofill, c tinyint(3) unsigned zerofill);

# 在整型类型数据上使用 zerofill 属性时，会自动添加 unsigned 属性
desc test3;
+-------+------------------------------+------+-----+---------+-------+
| Field | Type                         | Null | Key | Default | Extra |
+-------+------------------------------+------+-----+---------+-------+
| a     | tinyint                      | YES  |     | NULL    |       |
| b     | tinyint(3) unsigned zerofill | YES  |     | NULL    |       |
| c     | tinyint(3) unsigned zerofill | YES  |     | NULL    |       |
+-------+------------------------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

# 插入数据
# 有符号的 tinyint 数据存储区间为 -128 ~ 127
# 无符号的 tinyint 数据存储区间为 0 ~ 255
insert into test3 values(1, 1, 1), (-10, 10, 10), (-100, 100, 200);

select * from test3;
+------+------+------+
| a    | b    | c    |
+------+------+------+
|    1 |  001 |  001 |
|  -10 |  010 |  010 |
| -100 |  100 |  200 |
+------+------+------+
3 rows in set (0.00 sec)


# 以下为错误的case

insert into test3 values(-200, null, null);
# ERROR 1264 (22003): Out of range value for column 'a' at row 1

insert into test3 values(null, -1, null);
# ERROR 1264 (22003): Out of range value for column 'b' at row 1

insert into test3 values(null, 256, null);
# ERROR 1264 (22003): Out of range value for column 'b' at row 1
```

### 0填充 `ZEROFILL`

`ZEROFILL` 表示 0 填充，如果某一列整数使用了 `ZEROFILL` 属性，那么 mysql 会为当前列自动添加 `UNSIGNED` 属性。如果指定了 `ZEROFILL` 属性，保存的数值不够 `M` 位时，用 `0` 在左边填充。如果存储的数据超过 `M` 位时，只要数据不超过数据存储范围，可以正常保存;


在 `int(M)` 中，`M` 的值跟 `int(M)` 所占多少存储空间没有任何关系。`int(3)`、`int(4)`、`int(8)` 在磁盘上都是占用 `4字节` 的存储空间。

`int(M)` 必须和 `ZEROFILL` 一起使用才有意义。


### 适用场景

- `TINYINT`: 一般用于枚举数据，比如系统设定取值范围很小且固定的场景。
- `SMALLINT`: 可用于较小范围的统计数据，例如统计工厂的固定资产库存数量等。
- `MEDIUMINT`: 用于较大整数的计算，比如车站的每日客流量等。
- `INT、INTEGER`: 取值范围足够大，一般情况下不用考虑超限问题，用的最多、比如商品编号等。
- `BIGINT`: 处理特别巨大的数据时才会用到，比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。

## 浮点类型


### 浮点类型介绍

浮点数和定点数的特点是可以处理小数 ( 整数可以看成是小数的一个特例 )，浮点数和定点数的使用场景比整数类型多。

| 类型 |占用字节数 | 精度 |
| -- | -- | -- |
| `FLOAT` | 4字节 | 约 6 ~ 7 位有效数字 |
| `DOUBLE` | 8字节 | 约 15 位有效数字 |

### 数据精度说明

对于浮点类型数据，在 mysql 中，单精度使用 4 个字节，双精度使用 8 个字节。

- mysql 允许使用 非标准语法: `FLOAT(M, D) 或 DOUBLE(M, D)`，这里，`M` 称为 精度， `D` 称为 标度。`(M, D)` 中，`M=整数位+小数位`，`D=小数位`，`D <=M <= 255`, `0 <= D <= 30`;
  例如: 定义为 `FLOAT(5, 2)` 的列可以存储 `-999.99 ~ 999.99` 区间的数据，如果超过这个范围就会报错。
- `FLOAT` 和 `DOUBLE` 在不指定 `(M, D)` 时，默认会按照实际的精度来显示 (由实际的硬件和操作系统决定);
- 浮点类型也可以添加 `UNSIGNED` 属性，但是不会改变取数范围 ( ` 0 ~ 有符号的浮点数最大值` )
  例如: 定义为 `FLOAT(5 2) UNSIGNED`，只能存储 `0 ~ 999.99` 区间的数据;
- 不管是否显式设置了精度 `(M, D)`，这里 Mysql 的处理方案如下:
  - 如果存储时，整数部分超出了范围，mysql 会报错，不允许存储这样的值；
  - 如果存储时，小数部分超出了范围，有如下集中场景:
    - 若 四舍五入 后，整数部分没有超出范围，则只是警告，此时能够成功存储数据，存储的数据为 四舍五入 删除多余小数位后的值。
        例如: 在数据类型为 `FLOAT(5, 2)` 的列中插入 `999.009` 数值时，存储的是 `999.01`;
    - 若 四舍五入 后，整数部分超出了范围，则 MySQL报错，并拒绝处理。
        例如: 在数据类型为 `FLOAT(5, 2)` 的列中插入 `999.995` 和 `-999.95` 都会报错；
- 在 `MYSQL 8.0.17` 开始， `FLOAT(M, D)` 和 `DOUBLE(M, D)` 用法在官方文档中已经明确不推荐使用，将来可能被移除。另外，关于浮点类型 `FLOAT` 和 `DOUBLE` 的 `UNSIGNED` 属性也不推荐使用了。

```sql
create table if not exists test4(f1 float, f2 float(5, 2), d1 double, d2 double(5, 2));

desc test4;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| f1    | float       | YES  |     | NULL    |       |
| f2    | float(5,2)  | YES  |     | NULL    |       |
| d1    | double      | YES  |     | NULL    |       |
| d2    | double(5,2) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)


insert into test4 
values
(1234.123, 999.99, 1234.123, -999.99), 
(0.00001, 999.009, 0.00001, 999.009), 
(0.000001, 999.005, 0.2222222, 999.005);

select * from test4;
+----------+--------+-----------+---------+
| f1       | f2     | d1        | d2      |
+----------+--------+-----------+---------+
|  1234.12 | 999.99 |  1234.123 | -999.99 |
|  0.00001 | 999.01 |   0.00001 |  999.01 |
| 0.000001 | 999.00 | 0.2222222 |  999.00 |
+----------+--------+-----------+---------+
3 rows in set (0.00 sec)


# 以下是错误的case
insert into test4(null, 999.999, null, null);
# ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'null, 999.999, null, null)' at line 1
```

### 精度误差说明

浮点类型有个缺陷就是不精准，例如

```sql
create table if not exists test_d1(d1 double);

insert into test_d1 
values
(0.47), 
(0.44), 
(0.19);

select * from test_d1;
+------+
| d1   |
+------+
| 0.47 |
| 0.44 |
| 0.19 |
+------+
3 rows in set (0.00 sec)


# 求和
select sum(d1) from test_d1;
+--------------------+
| sum(d1)            |
+--------------------+
| 1.0999999999999999 |
+--------------------+
1 row in set (0.00 sec)


select sum(d1) = 1.1, 1.1 = 1.1 from test_d1;
+---------------+-----------+
| sum(d1) = 1.1 | 1.1 = 1.1 |
+---------------+-----------+
|             0 |         1 |
+---------------+-----------+
1 row in set (0.00 sec)
```

可以看到实际的计算结果是有误差的，原因是 mysql 用 4 个字节存储 float 类型数据，8 个字节存储 double 类型数据，无论哪个数据都是采用 二进制的形式 进行存储的。
例如: `9.625` 的 二进制为 `1001.101` 或者表达成 `1.001101 * 2^3`，如果尾数不是 0 或 5 ( 例如: 9.624 )，此时就无法用一个二进制精确表达，进而只好在取值允许的范围内进行四舍五入。

```
9.625 转成二进制

// 9  除2取余方式计算 得到 1001
9 / 2       ->  4       余  1
4 / 2       ->  2       余  0
2 / 2       ->  1       余  0
1 / 2       ->  0       余  1

// 0.625 乘2取整的方式计算  得到 101
0.625 * 2   ->  1.25    取整    1   余  0.25
0.25 * 2    ->  0.5     取整    0   余  0.5
0.5 * 2     ->  1       取整    1   余  0

推导得出 9.625 的二进制为 1001.101
```

在编程中，如果用到浮点数，需要特别注意误差问题，因为浮点数是不准确的，所以要避免使用 `=` 来判断两个数是否相等。同时，在一些精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，建议使用 定点数 `DECIMAL`;

## 定点数类型

### 类型介绍

mysql 中的定点数类型只有 `DECIMAL` 一种


| 数据类型 | 字节数 | 含义 |
| -- | -- | -- |
| `DECIMAL(M, D)` | M+2 字节 | 有效范围由 `M` 和 `D` 决定 |

使用 `DECIMAL(M, D)` 的方式表示高精度小数，其中 `M` 被称为精度，`D` 被称为标度，`0 <= M <= 65`, `0 <= D <= 30`, `D < M`，例如: `DECIMAL(5, 2)` 类型表示该列的取值范围为 `-999.99 ~ 999.99`;

- `DECIMAL(M,D)` 的最大取值范围与 `DOUBLE` 类型一样，但是有效数据范围是由 `M` 和 `D` 决定的。
- `DECIMAl` 的存储空间并不是固定的，由精度 `M` 决定，总共占用的存储空间为 `M + 2` 个字节，也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围会大一些。
- 定点数在 mysql 内部是以 字符串 的形式存储的，这就决定了它一定是精准的。
- 当 `DECIMAL` 类型不指定 精度和标度 时，其默认值为 `DECIMAL(10, 0)`，当数据超出了定点数类型的精度范围时，mysql 同样会进行四舍五入处理；

### 浮点数 vs 定点数

- 浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景。
- 定点数取值范围相对较小，当时精准，没有误差，适用于对精度要求极高的场景（例如：涉及金额计算的场景）；

```sql
create table if not exists test_d2(d1 decimal, d2 decimal(5, 2));

desc test_d2;
+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| d1    | decimal(10,0) | YES  |     | NULL    |       |
| d2    | decimal(5,2)  | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

insert into test_d2 values(123.12, 123.12);

# d1 字段为 decimal(10, 0) ，因此 123.12 存储到数据库中会四舍五入保留 0 位小数的数值 123
select * from test_d2;
+------+--------+
| d1   | d2     |
+------+--------+
|  123 | 123.12 |
+------+--------+
1 row in set (0.00 sec)
```

> 将 test_d1 表中的 d1 字段改成 `decimal(5, 2)` 后重新计算 sum

```sql
desc test_d1;
+-------+--------+------+-----+---------+-------+
| Field | Type   | Null | Key | Default | Extra |
+-------+--------+------+-----+---------+-------+
| d1    | double | YES  |     | NULL    |       |
+-------+--------+------+-----+---------+-------+
1 row in set (0.00 sec)

select * from test_d1;
+------+
| d1   |
+------+
| 0.47 |
| 0.44 |
| 0.19 |
+------+
3 rows in set (0.00 sec)


# 修改 d1 列的数据类型位 decimal(5, 2)
alter table test_d1 modify column d1 decimal(5, 2);

desc test_d1;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| d1    | decimal(5,2) | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
1 row in set (0.00 sec)

# 重新计算 sum ，得到精确的计算结果
select sum(d1) from test_d1;
+---------+
| sum(d1) |
+---------+
|    1.10 |
+---------+
1 row in set (0.00 sec)
```

# 位类型 `BIT`

`BIT` 位类型存储的是二进制值，类似 `0101110`;

| 二进制字符串类型 | 长度 | 长度范围 | 占用空间 |
| -- | -- | -- | -- |
| `BIT(M)` | `M` | `1 <= M <= 64` | 约为 `(M + 7) / 8` 个字节 |

`BIT` 类型如果没有指定 `M` ，默认是 `1` 位。这个 `1` 位表示只能存储 1 位的二进制值 ( 即: `M` 表示的是二进制的位数 )，位数最小值位 1， 最大值位 64；

```sql
create table if not exists test_d3(d1 bit, d2 bit(5), d3 bit(64));

desc test_d3;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| d1    | bit(1)  | YES  |     | NULL    |       |
| d2    | bit(5)  | YES  |     | NULL    |       |
| d3    | bit(64) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
3 rows in set (0.00 sec)

insert into test_d3 values(1, 10, 100), (0, 20, 200);

# 默认返回 16 进制值
# bin(column) 返回对应二进制值
# hex(column) 返回对应的 十六进制值
# column + 0 返回对应的十进制值
select d1, d2, d3, bin(d1), bin(d2), bin(d3), hex(d1), hex(d2), hex(d3), d1+0, d2+0, d3+0 from test_d3;
+------------+------------+--------------------+---------+---------+----------+---------+---------+---------+------+------+------+
| d1         | d2         | d3                 | bin(d1) | bin(d2) | bin(d3)  | hex(d1) | hex(d2) | hex(d3) | d1+0 | d2+0 | d3+0 |
+------------+------------+--------------------+---------+---------+----------+---------+---------+---------+------+------+------+
| 0x01       | 0x0A       | 0x0000000000000064 | 1       | 1010    | 1100100  | 1       | A       | 64      |    1 |   10 |  100 |
| 0x00       | 0x14       | 0x00000000000000C8 | 0       | 10100   | 11001000 | 0       | 14      | C8      |    0 |   20 |  200 |
+------------+------------+--------------------+---------+---------+----------+---------+---------+---------+------+------+------+
2 rows in set (0.00 sec)


# 以下为错误的示例
insert into test_d3 values(2, null, null);
# ERROR 1406 (22001): Data too long for column 'd1' at row 1
```


# 日期与时间类型

mysql 中有多种表示日期和时间的数据类型，不同版本可能有所差异，mysql 8.0 版本支持的日期和时间类型主要有: `YEAR` 类型、`DATE` 类型、`TIME` 类型、`DATETIME` 类型 和 `TIMESTAMP` 类型;

- `YEAR` 类型: 通常用来表示年
- `DATE` 类型: 通常用来表示年 月 日
- `TIME` 类型: 通常用来表示时 分 秒
- `DATETIME` 类型: 通常用来表示年 月 日 时 分 秒
- `TIMESTAMP` 类型: 通常用来表示带时区的年 月 日 时 分 秒

| 类型 | 名称 | 字节 | 日期格式 | 最小值 | 最大值 |
| -- | -- | -- | -- | -- | -- |
| `YEAR` | 年 | 1 | `YYYY` 或 `YY` | `1901` | `2155` |
| `DATE` | 日期 | 3 | `YYYY-MM-DD` | `1000-01-01` | `9999-12-03` |
| `TIME` | 时间 | 3 | `HH:MM:SS` | `-838:59:59` | `838:59:59` |
| `DATETIME` | 日期时间 | 8 | `YYYY-MM-DD HH:MM:SS` | `1000-01-01 00:00:00` | `9999-12-31 23:59:59` |
| `TIMESTAMP` | 时间戳 | 4 | `YYYY-MM-DD HH:MM:SS` | `1970-01-01 00:00:00 UTC` | `2038-01-19 03:14:07 UTC` |


## `YEAR` 类型

从 MySQL 5.7.5 开始，2 位格式（YEAR(2)）已被弃用并在后续版本中移除。

mysql 存储 year 类型数据时有以下几种存储格式:

- 以 四位 字符串 或 数字格式表示 year 类型，其格式为 `YYYY`，最小值为 `1901`、最大值为 `2155`;
- 以 两位 字符串 或 数字格式表示 year 类型，最小值为 `00`, 最大值为 `99`;
  - 取值 `01 ~ 69` 时，表示 `2001 ~ 2069`;
  - 取值 `70 ~ 99` 时，表示 `1970 ~ 1999`;
  - 取值数字 `0` 或 `00` 时，表示 `0000年`;
  - 取值字符串或日期的 `'0'` 时，表示 `2000年`;

```sql
create table if not exists test_year(y1 year, y2 year(4));

desc test_year;
+-------+------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+------+------+-----+---------+-------+
| y1    | year | YES  |     | NULL    |       |
| y2    | year | YES  |     | NULL    |       |
+-------+------+------+-----+---------+-------+
2 rows in set (0.00 sec)

insert into test_year values('2020', 2021);

select * from test_year;
+------+------+
| y1   | y2   |
+------+------+
| 2020 | 2021 |
+------+------+
1 row in set (0.00 sec)

# 取值 99 表示 1999 年
# 取值 01 表示 2001 年
insert into test_year values(99, 01);

# 取值 数字0 表示 0000 年
# 取值 字符串0 表示 2000 年
insert into test_year values(0, '0');

select * from test_year;
+------+------+
| y1   | y2   |
+------+------+
| 2020 | 2021 |
| 1999 | 2001 |
| 0000 | 2000 |
+------+------+
3 rows in set (0.00 sec)
```



## `DATE` 类型

`DATE` 类型表示日期，没有时间部分，格式为 `YYYY-MM-DD`，需要 3字节 的存储空间。在向 `DATE` 类型的字段插入数据时，同样需要满足一定的格式条件。

- `YYYY-MM-DD` 格式 或 `YYYYMMDD` 格式表示的字符串日期，其最小值为 `1000-01-01`，最大值为 `9999-12-03`。`YYYYMMDD` 格式会被转化为 `YYYY-MM-DD` 格式。
- 以 `YY-MM-DD` 格式或者 `YYMMDD` 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足 `YEAR` 类型的格式条件时，对应的年份会按照 `YEAR` 中的 `YY` 格式进行转换;
- 使用 `CURRENT_DATE()` 或 `NOW()` 函数，返回当前系统的日期;

```sql
create table if not exists test_date(d1 date);

desc test_date;
+-------+------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+------+------+-----+---------+-------+
| d1    | date | YES  |     | NULL    |       |
+-------+------+------+-----+---------+-------+
1 row in set (0.00 sec)

# 插入日期
insert into test_date values('20250611'), ('2025-06-10'), (20250609);

# 日期数据插入到数据库中后，会按照 YYYY-MM-DD 格式存储
select * from test_date;
+------------+
| d1         |
+------------+
| 2025-06-11 |
| 2025-06-10 |
| 2025-06-09 |
+------------+
3 rows in set (0.00 sec)

# 使用 YY-MM-DD 两位年份的格式保存日期数据时，年份数据会按照 YEAR 的 YY 格式转换
insert into test_date values('250606'), ('990606');

select * from test_date;
+------------+
| d1         |
+------------+
| 2025-06-11 |
| 2025-06-10 |
| 2025-06-09 |
| 2025-06-06 |  01 ~ 69  映射为 2001 ~ 2069
| 1999-06-06 |  70 ~ 99  映射为 1970 ~ 1999
+------------+
5 rows in set (0.00 sec)
```

## `TIME` 类型

`TIME` 类型表示时间，不包含日期部分。在 mysql 中 `TIME`类型 使用 3个字节 的存储空间存储数据。

在 mysql 中，向 `TIME` 类型的字段插入数据时，可以使用几种不同的格式：

1. 使用带冒号的字符串，`D HH:MM:SS`、`HH:MM:SS`、`HH:MM`、`D HH:MM`、`D HH` 或 `SS` 格式。
   - `D` 表示 天，最小值为 0，最大值为 34。
   - 如果使用带有 `D` 格式的字符串插入 `TIME` 类型的数据时，`D` 会被转换为 小时，计算格式为 `D*24+HH`.
   - 使用带冒号，且不带 `D`格式的字符串表示时间时，表示当天时间，例如: `12:00` 表示 `12:00:00`。
   - 使用不带冒号，且不带 `D` 格式的字符串表示时间时，mysql 会将最右边的两位解析成秒，例如 `1200`，表示 `00:12:00`。
2. 可以使用不带冒号的字符串或数字，格式为 `'HHMMSS'` 或 `HHMMSS`;
3. 如果插入一个不合法的字符串或者数字时，mysql 在存储数据时，会将其自动转化为 `00:00:00` 进行存储。
4. 使用 `CURRENT_TIME()` 或者 `NOW()` 会插入系统时间。
  
```sql
create table if not exists test_time (t1 time);

desc test_time;
+-------+------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+------+------+-----+---------+-------+
| t1    | time | YES  |     | NULL    |       |
+-------+------+------+-----+---------+-------+
1 row in set (0.00 sec)

# mysql 存储的 time 格式为 HH:MM:SS
insert into test_time values
(121110),       # 使用数字格式插入
('12:11:09'),   # 使用字符串格式插入
('12:11'),      # 字符串格式插入 HH:MM
(1211),         # 数字格式插入 MM:SS
('2 12:11:12'); # 加入天数 HH=2*24+12=60

select * from test_time;
+----------+
| t1       |
+----------+
| 12:11:10 |
| 12:11:09 |
| 12:11:00 |
| 00:12:11 |
| 60:11:12 |
+----------+
5 rows in set (0.00 sec)
```


## `DATETIME` 类型

`DATETIME` 类型在所有的日期和时间类型中，占用的存储空间最大，总共需要 8个字节 的存储空间。在格式上为 `DATE` + `TIME` 的组合，可以表示为 `YYYY-MM-DD HH:MM:SS`。

`DATETIME` 插入数据时，同样需要满足一定的格式:

- 以 `YYYY-MM-DD HH:MM:SS` 或 `YYYYMMDDHHMMSS` 格式的字符串插入 `DATETIME` 类型的字段时，最小值为 `1000-01-01 00:00:00`，最大值为 `9999-12-03 23:59:59`；
- 以 `YYYYMMDDHHMMSS` 格式插入的数据时，存储到数据库中会被转换成 `YYYY-MM-DD HH:MM:SS` 格式;
- 以 `YY-MM-DD HH:MM:SS` 或 `YYMMDDHHMMSS` 格式的字符串插入 `DATETIME` 类型的字段时，日期的处理方式同 `YEAR` 类型的年份处理方式处理；
- 使用函数 `CURRENT_TIMESTAMP()` 或 `NOW()` ，可以向 `DATETIME` 类型的字段插入系统的当前日期;

```sql
create table if not exists test_datetime(d1 datetime);

desc test_datetime;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| d1    | datetime | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
1 row in set (0.00 sec)

# datetime 类型的数据存储时，都会以 YYYY-MM-DD HH:MM:SS 格式存储
insert into test_datetime 
values
('2025-06-06 12:12:12'),  
('20250608121211'), 
(20250607121209),         # 按照 YYYYMMDDHHMMSS 格式的数字存储时，也会被格式化成对应的datetime 存储格式
('250601121212'), 
('990602121212');

select * from test_datetime;
+---------------------+
| d1                  |
+---------------------+
| 2025-06-06 12:12:12 |
| 2025-06-08 12:12:11 |
| 2025-06-07 12:12:09 |
| 2025-06-01 12:12:12 |
| 1999-06-02 12:12:12 |
+---------------------+
5 rows in set (0.00 sec)
```

## `TIMESTAMP` 类型

`TIMESTAMP` 存储的数据格式与 `DATETIME` 相同，都是以 `YYYY-MM-DD HH:MM:SS` 格式存储，占用 4个字节 的存储空间;

`TIMESTAMP` 存储的时间范围比 `DATETIME` 小得多，只能存储 `1970-01-01 00:00:00 UTC` 到 `2038-01-19 03:14:07 UTC` 之间的时间。其中 `UTC` 表示世界统一时间，也叫做世界标准时间；

```sql
create table if not exists test_timestamp(t1 timestamp);

desc test_timestamp;
+-------+-----------+------+-----+---------+-------+
| Field | Type      | Null | Key | Default | Extra |
+-------+-----------+------+-----+---------+-------+
| t1    | timestamp | YES  |     | NULL    |       |
+-------+-----------+------+-----+---------+-------+
1 row in set (0.00 sec)

# timestamp 类型的数据存储到数据库中时，也是以 YYYY-MM-DD HH:MM:SS 格式存储的
insert into test_timestamp values
('2025-06-06 12:12:12'), 
('20250606121211'), 
(20250606121209), 
(250601121200), 
(990602121212);

select * from test_timestamp;
+---------------------+
| t1                  |
+---------------------+
| 2025-06-06 12:12:12 |
| 2025-06-06 12:12:11 |
| 2025-06-06 12:12:09 |
| 2025-06-01 12:12:00 |
| 1999-06-02 12:12:12 |
+---------------------+
5 rows in set (0.00 sec)
```

## `TIMESTAMP` 和 `DATETIME` 的差异

- `TIMESTAMP` 存储空间小，表示的日期范围也比较小;
- 底层存储方式不同，`TIMESTAMP` 底层存储的是毫秒值，距离 `1970-01-01 00:00:00 0` 毫秒的毫秒值;
- 两个日期比较大小，或日期计算时，`TIMESTAMP` 更加方便，更快；
- `TIMESTAMP` 和时区有关，`TIMESTAMP` 会根据用户的时区不同，显示不同结果。`DATETIME` 只能反映出插入时当地的时区，其它时区的人看到时必然会有误差;

```sql
create table if not exists test_timestamp_datetime(t timestamp, d datetime);

desc test_timestamp_datetime;
+-------+-----------+------+-----+---------+-------+
| Field | Type      | Null | Key | Default | Extra |
+-------+-----------+------+-----+---------+-------+
| t     | timestamp | YES  |     | NULL    |       |
| d     | datetime  | YES  |     | NULL    |       |
+-------+-----------+------+-----+---------+-------+
2 rows in set (0.00 sec)

insert into test_timestamp_datetime values (now(), now());

select * from test_timestamp_datetime;
+---------------------+---------------------+
| t                   | d                   |
+---------------------+---------------------+
| 2025-06-11 15:16:52 | 2025-06-11 15:16:52 |
+---------------------+---------------------+
1 row in set (0.00 sec)

# 修改当前时区
set time_zone = '+9:00';

# 修改时区后重新查询，可以发现 timestamp 类型的数据跟着改变了
select * from test_timestamp_datetime;
+---------------------+---------------------+
| t                   | d                   |
+---------------------+---------------------+
| 2025-06-11 16:16:52 | 2025-06-11 15:16:52 |
+---------------------+---------------------+
1 row in set (0.00 sec)
```



# 文本字符串类型


mysql 中，文本字符串总体上分为 `CHAR`、`VARCHAR`、`TINYTEXT`、`TEXT`、`MEDIUMTEXT`、`LONGTEXT`、`ENUM`、`SET`等类型;

| 文本字符串类型 | 值的长度 | 长度范围 | 占用的存储空间 |
| -- | -- | -- | -- |
| `CHAR(M)` | `M` | `0 <= M <= 255` | `M` 个字节 |
| `VARCHAR(M)` | `M` | `0 <= M <= 65535` | `M+1` 个字节 |
| `TINYTEXT` | `L` | `0 <= L <= 255` | `L+2` 个字节 |
| `TEXT` | `L` | `0 <= L <= 65535` | `L+2` 个字节 |
| `MEDIUMTEXT` | `L` | `0 <= L <= 16777215 ` | `L+3` 个字节 |
| `LONGTEXT` | `L` | `0 <= L <= 4294967295` | `L+4` 个字节 |
| `ENUM` | `L` | `0 <= L <= 65535` | `1` 或 `2` 个字节 |
| `SET` | `L` | `0 <= L <= 64` | `1`、`2`、`3`、`4` 或 `8` 个字节 |


> 字符数量的计算

`VARCHAR` 存储的是可变长度字符串，实际能存储的字符数量取决于字符集

- 单字节字符集，例如: `latin1`
  - 1字节 = 1字符
  - 最大字符数 ≈ 65,535;
- 多字节字符集
  - `utf8mb3`: 最大 3字节 / 字符 -> 约 21,844 字符
  - `utf8mb4`: 最大 4字节 / 字符 -> 约 16,383 字符


## `CHAR` 与 `VARCHAR` 类型

`CHAR` 和 `VARCHAR` 类型都可以存储比较短的字符串。

### `CHAR` 类型

- `CHAR(M)` 类型一般需要预先定义字符串长度，如果不指定 `M` ，则表示长度默认是 `1` 个字符;
- 如果保存时，数据的实际长度比 `CHAR` 类型声明大的长度小，则会在 右侧填充 空格以达到指定长度。
- 当 mysql 检索 `CHAR` 类型的数据时，`CHAR` 类型的字段会去除尾部的空格;
- 定义 `CHAR` 类型字段时，声明的字段长度即为 `CHAR` 类型字段所占的存储空间的字节数;

```sql
create table if not exists test_char(c1 char, c2 char(5));

desc test_char;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| c1    | char(1) | YES  |     | NULL    |       |
| c2    | char(5) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)

insert into test_char values('a', 'abcde'), ('b', 'abc'), ('c', 'abc  ');

select c1, char_length(c1), c2, char_length(c2) from test_char;
+------+-----------------+-------+-----------------+
| c1   | char_length(c1) | c2    | char_length(c2) |
+------+-----------------+-------+-----------------+
| a    |               1 | abcde |               5 |
| b    |               1 | abc   |               3 |
| c    |               1 | abc   |               3 |  # 可以看到char类型的数据，查询时尾部的空格会被去除
+------+-----------------+-------+-----------------+
3 rows in set (0.00 sec)


## 以下是错误的case
insert into test_char values('ab', null);
ERROR 1406 (22001): Data too long for column 'c1' at row 1
```

### `VARCHAR` 类型

- `VARCHAR(M)` 定义时，必须指定长度 `M` ，否则报错；
- `mysql 5.0` 开始，`varchar(20)` 指的是 20 个字符;
- 检索 `VARCHAR` 类型的字段数据时，会保留数据尾部的空格；
- `VARCHAR` 类型的字段占用的存储空间为字符串实际长度 加 一个字节;


```sql
create table if not exists test_varchar(c1 varchar(10), c2 varchar(100));

desc test_varchar;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| c1    | varchar(10)  | YES  |     | NULL    |       |
| c2    | varchar(100) | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

insert into test_varchar values('abc', 'aabbcc'), ('abc  ', 'abbc  ');

select c1, char_length(c1), c2, char_length(c2) from test_varchar;
+-------+-----------------+--------+-----------------+
| c1    | char_length(c1) | c2     | char_length(c2) |
+-------+-----------------+--------+-----------------+
| abc   |               3 | aabbcc |               6 |
| abc   |               5 | abbc   |               6 |    # varchar 存储数据时，尾部的空格符号会被保留
+-------+-----------------+--------+-----------------+
2 rows in set (0.00 sec)
```

## `TEXT` 类型

mysql 中， `TEXT` 用来保存文本类型的字符串，总共包含四种类型: `TINYTEXT`、`TEXT`、`MEDIUMTEXT`、`LONGTEXT`;

在向 `TEXT` 类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度；

由于实际存储的长度不确定， mysql 不允许使用 `TEXT` 类型字段做主键。

TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text、blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。


### `VARCHAR` 与 `TEXT` 对比

| 特性 | `VARCHAR` | `TEXT` |
| -- | -- | -- |
| 存储位置 | 行内存储 (存储在表数据中) | 行外存储 (存储在表外，表内只保存指针) |
| 最大长度 | 65355字节(受行大小限制) | 65355字节 (长文本有 `MEDIUMTEXT` 等) |
| 索引支持 | 可以索引整个列 | 只能索引前缀 (前 255 个字符)  |
| 默认值 | 可以设置默认值 | 不能设置默认值 |
| 排序 | 可以使用整个列排序 | 只能使用前缀排序 |
| 内存表 | 支持 | 不支持 |


- `VARCHAR` 使用场景
  - 数据长度可变，但是相对较短 (如: 用户名，地址等)
  - 需要设置默认值
  - 需要对整个列建立索引或排序
  - 字段可能用于内存表
  - 数据通常小于几千字节
- `TEXT` 使用场景
  - 存储大段文本 (如: 文章内容，日志，评论等)
  - 数据长度可能超过几千字节
  - 不需要设置默认值
  - 不需要对整个列设置索引
  - 不需要在内存表中使用

> 性能考虑

- `VARCHAR` 通常比 `TEXT` 有更好的性能，因为数据存储在行内;
- `TEXT` 类型在查询时可能需要额外的 `I/O` 操作来获取数据;
- 对于非常大的文本，考虑使用 `MEDIUMTEXT` 或 `LONGTEXT` ;


# `ENUM`类型

`ENUM` 枚举类型，取值范围需要在定义字段的时候指定。设置字段值时，`ENUM` 类型只允许从成员中选取单个值，不能一个选多个值。

- 当 `ENUM` 类型包含 `1 ~ 255` 个成员时，需要一个字节的存储空间；
- 当 `ENUM` 类型包含 `256 ~ 65535` 个成员时，需要两个字节的存储空间;
- `ENUM` 类型的成员个数的上限是 `65535` 个;

```sql
create table if not exists test_enum(season enum('春','夏','秋','冬','unknow') default 'unknow');

desc test_enum;
+--------+------------------------------------+------+-----+---------+-------+
| Field  | Type                               | Null | Key | Default | Extra |
+--------+------------------------------------+------+-----+---------+-------+
| season | enum('春','夏','秋','冬','unknow') | YES  |     | unknow  |       |
+--------+------------------------------------+------+-----+---------+-------+
1 row in set (0.00 sec)

# 忽略大小写
insert into test_enum values('春'),('秋'),('unknow'),('UNKNOW');

select * from test_enum;
+--------+
| season |
+--------+
| 春     |
| 秋     |
| unknow |
| unknow |
+--------+
4 rows in set (0.00 sec)


# 以下是错误的 case
insert into test_enum values('未知');
ERROR 1265 (01000): Data truncated for column 'season' at row 1
```



# `SET` 类型

`SET` 表示一个字符串对象，可以包含 0个 或 多个 成员，但成员个数上限是 64; 设置字段值，可以取取值范围内的 0个 或 多个值;

| 成员个数范围 (L表示实际成员个数) | 占用的存储空间 |
| -- | -- |
| `1 <= L <= 8` | 1个字节 |
| `9 <= L <= 16` | 2个字节 |
| `17 <= L <= 24` | 3个字节 |
| `25 <= L <= 32` | 4个字节 |
| `33 <= L <= 64` | 8个字节 |

```sql
create table if not exists test_set(s set('A', 'B', 'C', 'UNKNOW') default 'UNKNOW');

desc test_set;
+-------+---------------------------+------+-----+---------+-------+
| Field | Type                      | Null | Key | Default | Extra |
+-------+---------------------------+------+-----+---------+-------+
| s     | set('A','B','C','UNKNOW') | YES  |     | UNKNOW  |       |
+-------+---------------------------+------+-----+---------+-------+
1 row in set (0.00 sec)

# 插入时，忽略大小写
insert into test_set values('A'),('A,B'),('A,b,c');

select * from test_set;
+-------+
| s     |
+-------+
| A     |
| A,B   |
| A,B,C |
+-------+
3 rows in set (0.00 sec)

# 以下是错误的 case
insert into test_set values('D');
ERROR 1265 (01000): Data truncated for column 's' at row 1
```


# 二进制字符串类型

mysql 中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。

mysql 中支持的二进制字符串类型主要包括 `BINARY`、`VARBINARY`、`TINYBLOB`、`MEDIUMBLOB`、`LONGBLOB`；

## `BINARY` 和 `VARBINARY` 类型

`BINARY` 和 `VARBINARY` 类似于 `CHAR` 和 `VARCHAR`，只不过他们存储的是二进制字符串。

`BINARY(M)` 为固定长度二进制字符串，`M` 表示能存储的最大字节数，取值范围是 `0 ~ 255` ，默认为 `1`。如果存储的数据长度小于 `M` 个字节，则存储时，会在右侧填充 `\0` 以补齐长度;

`VARBINARY` 为可变长度二进制字符串，`M` 表示能存储的最大字节数 ( `M` 必填 )，总字节数不能超过行的字节长度 `65535`。此外 `VARBINARY` 还需要 一两个字节来存储数据的字节数。

```sql
# varbinary 必须指定 M
create table if not exists test_binary(b1 binary, b2 binary(3), b3 varbinary(10));

desc test_binary;
+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| b1    | binary(1)     | YES  |     | NULL    |       |
| b2    | binary(3)     | YES  |     | NULL    |       |
| b3    | varbinary(10) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

insert into test_binary values('a', 'ab', 'abc');

select * from test_binary;
+------------+------------+------------+
| b1         | b2         | b3         |
+------------+------------+------------+
| 0x61       | 0x616200   | 0x616263   |
+------------+------------+------------+
1 row in set (0.00 sec)


# 以下是错误的 case
insert into test_binary values('中', null, null);
ERROR 1406 (22001): Data too long for column 'b1' at row 1
```

## `BLOB` 类型

`BLOB` 是一个二进制大对象，可存储可变数量的数据。

MySQL中的 `BLOB` 类型包括 `TINYBLOB`、`BLOB`、`MEDIUMBLOB`和`LONGBLOB` 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如图片、音频和视频等。
需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到服务器的磁盘上，并将图片、音频和视频的访问路径存储到MySQL中。

> 在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。

1. BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的"空洞"，以后填入这些"空洞"的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行碎片整理。
2. 如果需要对大文本字段进行模糊查询，MySQL 提供了前缀索引。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。
3. 把BLOB或TEXT列分离到单独的表中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会减少主表中的碎片，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。


# `JSON` 类型

JSON 是一种轻量级的数据交换格式。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。

在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。

当需要检索JSON类型的字段中数据的某个具体值时，可以使用 `->` 和 `->>` 符号。

```sql
create table if not exists test_json(j json);

desc test_json;
+-------+------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+------+------+-----+---------+-------+
| j     | json | YES  |     | NULL    |       |
+-------+------+------+-----+---------+-------+
1 row in set (0.00 sec)

insert into test_json values('{"name":"zhangsan", "age":10}');

select * from test_json;
+---------------------------------+
| j                               |
+---------------------------------+
| {"age": 10, "name": "zhangsan"} |
+---------------------------------+
1 row in set (0.00 sec)

# 查询 json 中的某一个字段

select j -> '$.name' as name, j -> '$.age' as age from test_json;
+------------+------+
| name       | age  |
+------------+------+
| "zhangsan" | 10   |
+------------+------+
1 row in set (0.00 sec)
```










